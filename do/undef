int						/*SUPPRESS 590*/
do_undef(TARG,arg,gimme,arglast)
STR *TARG;
register ARG *arg;
int gimme;
int *arglast;
{
    register int type;
    register STAB *stab;
    int retarg = arglast[0] + 1;

    if ((arg[1].arg_type & A_MASK) != A_LEXPR)
	fatal("Illegal argument to undef()");
    arg = arg[1].arg_ptr.arg_arg;
    type = arg->arg_type;

    if (type == O_ARRAY || type == O_LARRAY) {
	stab = arg[1].arg_ptr.arg_stab;
	afree(stab_xarray(stab));
	stab_xarray(stab) = anew(stab);		/* so "@array" still works */
    }
    else if (type == O_HASH || type == O_LHASH) {
	stab = arg[1].arg_ptr.arg_stab;
	if (stab == envstab)
	    environ[0] = Nullch;
	else if (stab == sigstab) {
	    int i;

	    for (i = 1; i < NSIG; i++)
		signal(i, SIG_DFL);	/* munch, munch, munch */
	}
	(void)hfree(stab_xhash(stab), TRUE);
	stab_xhash(stab) = Null(HASH*);
    }
    else if (type == O_SUBR || type == O_DBSUBR) {
	stab = arg[1].arg_ptr.arg_stab;
	if ((arg[1].arg_type & A_MASK) != A_WORD) {
	    STR *tmpstr = STAB_STR(arg[1].arg_ptr.arg_stab);

	    if (tmpstr)
		stab = stabent(str_get(tmpstr),TRUE);
	    else
		stab = Nullstab;
	}
	if (stab && stab_sub(stab)) {
	    cmd_free(stab_sub(stab)->cmd);
	    stab_sub(stab)->cmd = Nullcmd;
	    afree(stab_sub(stab)->tosave);
	    Safefree(stab_sub(stab));
	    stab_sub(stab) = Null(SUBR*);
	}
    }
    else
	fatal("Can't undefine that kind of object");
    str_numset(TARG,0.0);
    stack->ary_array[retarg] = TARG;
    return retarg;
}

