# $Header$ 
# basic C types
int			T_INT
unsigned		T_U_INT
unsigned int		T_U_INT
long			T_LONG
unsigned long		T_U_LONG
short			T_SHORT
unsigned short		T_U_SHORT
char			T_CHAR
char *			T_STRING
unsigned char *		T_STRING
caddr_t			T_STRING
unsigned long *		T_OPAQUEPTR
char **			T_PACKED
void *			T_PTR

I32			T_LONG
I16			T_SHORT
U32			T_U_LONG
U16			T_U_SHORT
Result			T_U_CHAR
Boolean			T_U_CHAR
double			T_DOUBLE

#############################################################################
INPUT
T_INT
	$var = (int)SvIV($arg)
T_ENUM
	$var = ($type)SvIV($arg)
T_U_INT
	$var = (unsigned int)SvIV($arg)
T_SHORT
	$var = (short)SvIV($arg)
T_U_SHORT
	$var = (unsigned short)SvIV($arg)
T_LONG
	$var = (long)SvIV($arg)
T_U_LONG
	$var = (unsigned long)SvIV($arg)
T_CHAR
	$var = (char)*SvPV($arg,na)
T_U_CHAR
	$var = (unsigned char)SvIV($arg)
T_FLOAT
	$var = (float)SvNV($arg)
T_DOUBLE
	$var = SvNV($arg)
T_STRING
	$var = SvPV($arg,na)
T_PTR
	$var = ($type)(unsigned long)SvNV($arg)
T_PTRREF
	if (SvROK($arg))
	    $var = ($type)(unsigned long)SvNV((SV*)SvRV($arg));
	else
	    croak(\"$var is not a reference\")
T_PTROBJ
	if (sv_isa($arg, \"${ntype}\"))
	    $var = ($type)(unsigned long)SvNV((SV*)SvRV($arg));
	else
	    croak(\"$var is not of type ${ntype}\")
T_PTRDESC
	if (sv_isa($arg, \"${ntype}\")) {
	    ${type}_desc = (\U${type}_DESC\E*)(unsigned long)SvNV((SV*)SvRV($arg));
	    $var = ${type}_desc->ptr;
	}
	else
	    croak(\"$var is not of type ${ntype}\")
T_REFREF
	if (SvROK($arg))
	    $var = *($type)(unsigned long)SvNV((SV*)SvRV($arg));
	else
	    croak(\"$var is not a reference\")
T_REFOBJ
	if (sv_isa($arg, \"${ntype}\"))
	    $var = *($type)(unsigned long)SvNV((SV*)SvRV($arg));
	else
	    croak(\"$var is not of type ${ntype}\")
T_OPAQUE
	$var NOT IMPLEMENTED
T_OPAQUEPTR
	$var = ($type)SvPV($arg,na)
T_PACKED
	$var = XS_unpack_$ntype($arg)
T_PACKEDARRAY
	$var = XS_unpack_$ntype($arg)
T_CALLBACK
	$var = make_perl_cb_$type($arg)
T_ARRAY
	$var = $ntype(items -= $argoff);
	U32 ix_$var = $argoff;
	while (items--) {
	    DO_ARRAY_ELEM;
	}
#############################################################################
OUTPUT
T_INT
	sv_setiv($arg, (I32)$var);
T_ENUM
	sv_setiv($arg, (I32)$var);
T_U_INT
	sv_setiv($arg, (I32)$var);
T_SHORT
	sv_setiv($arg, (I32)$var);
T_U_SHORT
	sv_setiv($arg, (I32)$var);
T_LONG
	sv_setiv($arg, (I32)$var);
T_U_LONG
	sv_setiv($arg, (I32)$var);
T_CHAR
	sv_setpvn($arg, (char *)&$var, 1);
T_U_CHAR
	sv_setiv($arg, (I32)$var);
T_FLOAT
	sv_setnv($arg, (double)$var);
T_DOUBLE
	sv_setnv($arg, $var);
T_STRING
	sv_setpv($arg, $var);
T_PTR
	sv_setnv($arg, (double)(unsigned long)$var);
T_PTRREF
	sv_setptrref($arg, $var);
T_PTROBJ
	sv_setptrobj($arg, $var, \"${ntype}\");
T_PTRDESC
	sv_setptrobj($arg, (void*)new\U${type}_DESC\E($var), \"${ntype}\");
T_REFREF
	sv_setrefref($arg, \"${ntype}\", XS_service_$ntype,
		    ($var ? (void*)new $ntype($var) : 0));
T_REFOBJ
	NOT IMPLEMENTED
T_OPAQUE
	sv_setpvn($arg, (char *)&$var, sizeof($var));
T_OPAQUEPTR
	sv_setpvn($arg, (char *)$var, sizeof(*$var)), XFree((char *)$var);
T_PACKED
	XS_pack_$ntype($arg, $var);
T_PACKEDARRAY
	XS_pack_$ntype($arg, $var, count_$ntype);
T_DATAUNIT	
	sv_setpvn($arg, $var.chp(), $var.size());
T_CALLBACK
	sv_setpvn($arg, $var.context.value().chp(),
		$var.context.value().size());
T_ARRAY
	ST_EXTEND($var.size);
	for (U32 ix_$var = 0; ix_$var < $var.size; ix_$var++) {
		ST(ix_$var) = sv_newmortal();
	DO_ARRAY_ELEM
	}
	sp += $var.size - 1;
