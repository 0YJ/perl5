Modules
	POSIX (in progress)
	X/Motif/Tk etc.

Tie Modules
	VecArray		Implement array using vec()
	SubstrArray		Implement array using substr()
	VirtualArray		Implement array using a file
	ShiftSplice		Defines shift et al in terms of splice method

Bugs
	Make yyparse recursion longjmp() proof.
	Make "delete $array{$key} while ($key) = each %array" safe
	Wrong line reported for runtime elsif condition error

Regexp extensions
	/m  for multiline
	/\Afoo/ (beginning of string, or where previous g match left off)
	/foo\Z/ (end of string only)
	negative regexp assertions?
	/<>/x for grouping?
	/f for fixed variable interpolation?
	Rewrite regexp parser for better integrated optimization

Would be nice to have
	Profiler
	pack "(stuff)*"
	lexperl
	Bundled perl preprocessor
	Make $[ compile-time instead of run-time
	Use posix calls internally where possible
	const variables
	gettimeofday
	bytecompiler
	format BOTTOM
	willcall()
	-iprefix.
	All ARGV input should act like <>
	Multiple levels of warning

Pragmas ("assume" maybe?)
	integer, float
	nodebug, debug
	autocroak?

Optimizations
	Optimize switch statements
	Optimize foreach on array
	Optimize foreach (1..1000000)
	Set KEEP on constant split
	Cache eval tree (unless lexical outer scope used (mark in &compiling?))
	rcatmaybe
	Shrink opcode tables via multiple implementations selected in peep
	Cache hash value?
	Optimize away @_ where possible
	sfio?
	"one pass" global destruction

Need to think more about
	ref function in list context
	Populate %SIG at startup if appropriate
	write HANDLE [formats].

Vague possibilities
	sub mysplice(@, $, $, ...)
	data prettyprint function?  (or is it, as I suspect, a lib routine?)
	Nested destructors
	make tr/// return histogram in list context?
	undef wantarray in void context
	Loop control on do{} et al
	Explicit switch statements
	perl to C translator
	multi-thread scheduling
	built-in globbing
	compile to real threaded code
	structured types
	paren counting in tokener to queue remote expectations
