    len = sv->sv_cur;
    e = sv->sv_ptr + len;
    if (delim == '\'')
	d = e;
    else
	d = sv->sv_ptr;
    for (; d < e; d++) {
	if (*d == '\\')
	    d++;
	else if ((*d == '$' && d[1] && d[1] != '|' && d[1] != ')') ||
		 (*d == '@')) {
	    lex_stuff = newSVsv(sv);
	    d = scan_ident(d,bufend,buf,FALSE);
	    (void)gv_fetchpv(buf,TRUE);		/* make sure it's created */
	    for (; d < e; d++) {
		if (*d == '\\')
		    d++;
		else if (*d == '$' && d[1] && d[1] != '|' && d[1] != ')') {
		    d = scan_ident(d,bufend,buf,FALSE);
		    (void)gv_fetchpv(buf,TRUE);
		}
		else if (*d == '@') {
		    d = scan_ident(d,bufend,buf,FALSE);
		    if (strEQ(buf,"ARGV") || strEQ(buf,"ENV") ||
		      strEQ(buf,"SIG") || strEQ(buf,"INC"))
			(void)gv_fetchpv(buf,TRUE);
		}
	    }
	    pm->op_pmflags |= PMf_RUNTIME;
	    goto got_pat;		/* skip compiling for now */
	}
    }
    if (pm->op_pmflags & PMf_FOLD)
	StructCopy(pm, &savepm, PMOP);
    scan_prefix(pm,sv->sv_ptr,len);
    if ((pm->op_pmflags & PMf_ALL) && (pm->op_pmflags & PMf_SCANFIRST)) {
	fbm_compile(pm->op_pmshort, pm->op_pmflags & PMf_FOLD);
	pm->op_pmregexp = regcomp(sv->sv_ptr,sv->sv_ptr+len,
	    pm->op_pmflags & PMf_FOLD);
		/* Note that this regexp can still be used if someone says
		 * something like /a/ && s//b/;  so we can't delete it.
		 */
    }
    else {
	if (pm->op_pmflags & PMf_FOLD)
	    StructCopy(&savepm, pm, PMOP);
	if (pm->op_pmshort)
	    fbm_compile(pm->op_pmshort, pm->op_pmflags & PMf_FOLD);
	pm->op_pmregexp = regcomp(sv->sv_ptr,sv->sv_ptr+len,
	    pm->op_pmflags & PMf_FOLD);
	hoistmust(pm);
    }
  got_pat:
